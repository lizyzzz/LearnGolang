### 第 2 章 容易混淆知识点
* 实体第一个字母的大小写决定其可见性是否跨包。如果首字母大写，说明是对包外可见的，可以被包外的程序所引用，像fmt的Printf。
* new 函数：new(T) 返回一个 type 为 T 的指针，但是不能确定是在堆区还是栈区申请内存。
```
func f() *int {
  v := 1
  return &v
}

var p = f() // p 依然有效

// 这两个函数有着同样的行为
func newInt() *int {
  return new(int)
}
func newInt() *int {
  var dummy int
  return &dummy
}
```
* 对象的生命周期：包级别的变量的生命周期与整个程序的生命周期一样。局部变量的生命周期是动态的：即一直生存到它变得不可访问，这时占用的存储空间被回收。“不可访问”是指访问变量的路径（变量名，指针，引用等）不存在。在堆区或者栈区创建变量是由编译器决定，而不是由 var 或 new 决定。
```
// 这种情况称为 x 从 f 逃逸
var global *int
func f() {
  var x int
  x = 1
  global = &x // x 一定创建在堆区
}

func g() {
  y := new(int) // y 被创建在 栈区, 即使是 new 函数创建的
  *y = 1
}
```
* 垃圾回收机制对写出正确的代码很有帮助，但要注意变量的生命周期。
