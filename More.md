## 第 2 章 容易混淆知识点
* 实体第一个字母的大小写决定其可见性是否跨包。如果首字母大写，说明是对包外可见的，可以被包外的程序所引用，像fmt的Printf。
* new 函数：new(T) 返回一个 type 为 T 的指针，但是不能确定是在堆区还是栈区申请内存。
```
func f() *int {
  v := 1
  return &v
}

var p = f() // p 依然有效

// 这两个函数有着同样的行为
func newInt() *int {
  return new(int)
}
func newInt() *int {
  var dummy int
  return &dummy
}
```
* 对象的生命周期：包级别的变量的生命周期与整个程序的生命周期一样。局部变量的生命周期是动态的：即一直生存到它变得不可访问，这时占用的存储空间被回收。“不可访问”是指访问变量的路径（变量名，指针，引用等）不存在。在堆区或者栈区创建变量是由编译器决定，而不是由 var 或 new 决定。
```
// 这种情况称为 x 从 f 逃逸
var global *int
func f() {
  var x int
  x = 1
  global = &x // x 一定创建在堆区
}

func g() {
  y := new(int) // y 被创建在 栈区, 即使是 new 函数创建的
  *y = 1
}
```
* 垃圾回收机制对写出正确的代码很有帮助，但要注意变量的生命周期。
* 多重赋值问题：在实际更新变量前，右边所有的表达式被推演。
```
x, y = y, x // 交换 x y 的值
// 求最大公约数
func gcd(x, y int) int {
  for y != 0 {
    x, y = y, x % y
  }
}
```
* 短变量声明问题：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，那么对于这些变量，短声明等同于赋值。
```
in, err := os.Open(infile) // 声明 in err
// ...
out, err := os.Create(outfile) // 声明 out, 赋值 err
in, err := os.Create(outfile) // 错误, 没有新的变量
//---------------------------
特别注意: 只有在同一个词法块中已经存在变量的情况下, 短声明的行为才和赋值操作一样, 外层的声明将被忽略。
```
* 类型声明(别名)：如果名字是导出的(首字母大写)，其它包也可以访问.
```
// type name underlying-type
type Index int
type Loop int
// Index Loop 虽然底层都是int，但是是不同的类型
var i Index = 1
var l Loop = Loop(i) // 显式类型转换  
```
## 第 3 章容易混淆知识点
* 类型转换要显示进行，例如：int 和 int32 不是同一种类型，尽管它们可能都是32位来表示。使用时需要显式转换。
* 位运算中：& | ^ << >> ：其中 ^ 可以作为一元运算符表示 ~ (cpp 中 ~ 表示 按位非)，也可以作为二元运算符表示异或。
* 通常 Printf 的格式化字符串含有多个 % 谓词，这要求提供相同数量的操作数，而 % 后的副词 [1] 告知 Printf 使用第一个操作数。而 # 告知 Printf 输出相应的前缀。
```
o := 0666 // 八进制数
fmt.Printf("%d %[1]o %#[1]o\n", o) // 输出 438 666 0666
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x) // 输出 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
* 字符串相关问题：GO语言的字符串用 UTF-8 编码。
```
// (1) 字符串的第 i 个字节不一定就是第 i 个字符，因为非 ASCII 字符的 UTF-8 码点需要两个字节来表示。
// (2) 字符串的单个字节指不能被修改，但可以整个字符串重新赋值。不可变意味着复制的字符串或子串共用一个内存。
s := "hello"
s[0] = 'L' // 编译错误
```
* 字符串字面量使用双引号 "" 或者反引号 ` 来创建。
```
双引号用来创建可解析的字符串，支持转义，但不能用来引用多行。-----双引号创建可解析的字符串应用最广泛
反引号用来创建原生的字符串字面量，可能由多行组成，但不支持转义，并且可以包含除了反引号外其他所有字符。-----反引号用来创建原生的字符串则多用于书写多行信息，HTML以及正则表达式。
```
* 变长UTF-8 编码
```
0~127： 0xxxxxxx 表示，首位是 0
128～2047：110xxxxx 10xxxxxx 表示，第一字节首位是 110，第二字节首位是 10
2048～65535：1110xxxx 10xxxxxx 10xxxxxx 表示，第一字节首位是 1110，第二字节首位是 10，第三字节首位是 10
有些不可以用键盘输入的字符，可以用转义序列表示
\uhhhh，其中 h 是16进制数，两个字节的转义
\xhh，表示的是一个字节转义
```
* 字符串与字节slice
```
// 4个标准包对字符串操作特别重要：bytes, strings, strconv, unicode
strings: 提供了函数，用于搜索，替换，比较，修整，切分与连接字符串
bytes: 也有类似函数，用于操作字节slice ([]byte 类型)
strconv: 提供的函数，用于转换布尔值，整数，浮点数为与之对应的字符串形式，或者把字符串转换为布尔值，整数，浮点数，或添加/去除引号
unicode: 具有判别文字符号值等特性的函数，如IsDigit、IsLetter、IsUpper等
// 字符串无法修改单个字节，但 字节slice 可以修改
s := "hello"
s[0] = 'L' // 编译错误
b := []byte(s) // 类型转换为 []byte, 并且会复制一份副本, 填入 s 含有的字节, 并生成一个 slice 引用指向整个数组
b[1] = 'a' // 正确
```
* bytes 包提供的 Buffer 类型可以高效处理 []byte
* 注意无类型常量的写法。
```
var f float64 = 212
fmt.Println((f - 32) * 5 / 9) // 100, (f - 32) * 5 的结果是 float64 型
fmt.Println(5 / 9 * (f - 32)) // 0, 5 / 9 的结果是 无类型整数 0
fmt.Println(5.0 / 9.0 * (f - 32)) // 0, 5.0 / 9.0 的结果是 无类型浮点数
```
## 第 4 章容易混淆知识点
* 数组：(使用较少)
```
// (1) 不同长度的数组是不同的类型。
// (2) 可以在初始化列表中使用下标的方式给指定下标的位置赋值
symbol := [...]int{99: -1} // symbol 的长度是 100, 第100位是 -1
// (3) 不确定长度的数组可以由列表初始化的个数决定。用 ... 表示
q := [...]int{3, 2, 1} // q 的长度是 3
// (4) 数组类型可比较的话, 数组也可比较
// (5) 数组作为函数参数是值传递 (与 cpp 不一样), 但也可以显式指定为指针传递。
func zero(val [32]byte) {
  // 值传递
}
func zero(ptr *[32]byte) {
  // 指针传递
}
```
* slice：(使用较多)
```
// (1) slice 有三个属性: 指针, 长度, 容量。指针指向底层数组的第一个可以从slice中访问的元素, 这个元素不一定是数组的第一个元素。
// (2) 一个底层数组可以对应多个 slice, 被不同的 slice 引用。
// (3) 当一个 slice 引用一个底层数组的子数组时, 引用不可以超过数组的边界, 但引用可以扩展 slice。
q1 := []string{1: "Jan", 12: "Dec"} // 长度为 13
summer := q1[6:9] // 长度为 3
fmt.Println(summer[:20]) // 宕机: 超出数组边界
endless := summer[:5]    // 在 slice 容量范围扩展了 slice
// (4) 注意 string 和 []byte 的区别，x[m:n]都返回原始字节的一个子序列，都是常量时间，引用方式也相同。区别在于 string 返回的是一个字符串, []byte返回的是一个字节slice
// (5) 因为 slice 包含了指向数组元素的指针, 所以将一个 slice 传递给函数时, 可以被修改。相当于创建了一个别名。
// (6) 不能对两个 slice 做比较, 标准库提供 bytes.Equal 来比较两个字节 slice，但其他类型的 slice 只能自己写函数来比较。
// (7) 值为 nil 的没有对应的底层数组，容量和长度都是 0, 但容量和长度都是 0 的 slice 不一定为 nil, 如 []int{}
// (8) make() 函数可以创建一个 slice
make([]T, len) // 引用整个数组, len == cap
make([]T, len, cap) // 引用 len 个, len <= cap
// (9) 使用 append 函数 将元素追加到 slice 后面。扩容策略与 cpp 的 vector 一样。
str := "hello"
s := make([]string, 0, 10)
s = append(s, str) // 这里的返回值底层数组可能发生变化，所以要接受返回值
s = append(s, str, str, str) // 这里的参数可以变化
// (10) slice 可以使用 reverse, rotate 等函数实现就地修改 slice 元素。
```
* map: 类型是 map[k]v， 也是引用类型
```
// (1) 键的类型必须可 == 比较。
ages := map[string]int {
  "alice": 31,
  "charlie": 34,
}
等价于
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
ages := map[string]int{} // 新的空的map
// (2) 增改查删
ages["alice"] = 10 // 增改查
delete(ages, "alice") // 删
// (3) map 的顺序是不一定的
// (4) map 必须初始化才能使用
var ages map[string]int
ages["bob"] = 20 // 错误, 为 nil 值 map 赋值
// (5) map 不可比较
// (6) 当 key 不可比较时，可以自定义一个函数, 先把不可比较的 key 映射到唯一的可比较类型集合
```



  


