## 第 2 章 容易混淆知识点
* 实体第一个字母的大小写决定其可见性是否跨包。如果首字母大写，说明是对包外可见的，可以被包外的程序所引用，像fmt的Printf。
* new 函数：new(T) 返回一个 type 为 T 的指针，但是不能确定是在堆区还是栈区申请内存。
```
func f() *int {
  v := 1
  return &v
}

var p = f() // p 依然有效

// 这两个函数有着同样的行为
func newInt() *int {
  return new(int)
}
func newInt() *int {
  var dummy int
  return &dummy
}
```
* 对象的生命周期：包级别的变量的生命周期与整个程序的生命周期一样。局部变量的生命周期是动态的：即一直生存到它变得不可访问，这时占用的存储空间被回收。“不可访问”是指访问变量的路径（变量名，指针，引用等）不存在。在堆区或者栈区创建变量是由编译器决定，而不是由 var 或 new 决定。
```
// 这种情况称为 x 从 f 逃逸
var global *int
func f() {
  var x int
  x = 1
  global = &x // x 一定创建在堆区
}

func g() {
  y := new(int) // y 被创建在 栈区, 即使是 new 函数创建的
  *y = 1
}
```
* 垃圾回收机制对写出正确的代码很有帮助，但要注意变量的生命周期。
* 多重赋值问题：在实际更新变量前，右边所有的表达式被推演。
```
x, y = y, x // 交换 x y 的值
// 求最大公约数
func gcd(x, y int) int {
  for y != 0 {
    x, y = y, x % y
  }
}
```
* 短变量声明问题：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明，那么对于这些变量，短声明等同于赋值。
```
in, err := os.Open(infile) // 声明 in err
// ...
out, err := os.Create(outfile) // 声明 out, 赋值 err
in, err := os.Create(outfile) // 错误, 没有新的变量
//---------------------------
特别注意: 只有在同一个词法块中已经存在变量的情况下, 短声明的行为才和赋值操作一样, 外层的声明将被忽略。
```
* 类型声明(别名)：如果名字是导出的(首字母大写)，其它包也可以访问.
```
// type name underlying-type
type Index int
type Loop int
// Index Loop 虽然底层都是int，但是是不同的类型
var i Index = 1
var l Loop = Loop(i) // 显式类型转换  
```
## 第 3 章容易混淆知识点
* 类型转换要显示进行，例如：int 和 int32 不是同一种类型，尽管它们可能都是32位来表示。使用时需要显式转换。
* 位运算中：& | ^ << >> ：其中 ^ 可以作为一元运算符表示 ~ (cpp 中 ~ 表示 按位非)，也可以作为二元运算符表示异或。
* 通常 Printf 的格式化字符串含有多个 % 谓词，这要求提供相同数量的操作数，而 % 后的副词 [1] 告知 Printf 使用第一个操作数。而 # 告知 Printf 输出相应的前缀。
```
o := 0666 // 八进制数
fmt.Printf("%d %[1]o %#[1]o\n", o) // 输出 438 666 0666
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x) // 输出 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
* 字符串相关问题：GO语言的字符串用 UTF-8 编码。
```
// (1) 字符串的第 i 个字节不一定就是第 i 个字符，因为非 ASCII 字符的 UTF-8 码点需要两个字节来表示。
// (2) 字符串的单个字节指不能被修改，但可以整个字符串重新赋值。不可变意味着复制的字符串或子串共用一个内存。
s := "hello"
s[0] = 'L' // 编译错误
```
* 字符串字面量使用双引号 "" 或者反引号 ` 来创建。
```
双引号用来创建可解析的字符串，支持转义，但不能用来引用多行。-----双引号创建可解析的字符串应用最广泛
反引号用来创建原生的字符串字面量，可能由多行组成，但不支持转义，并且可以包含除了反引号外其他所有字符。-----反引号用来创建原生的字符串则多用于书写多行信息，HTML以及正则表达式。
```
* 变长UTF-8 编码
```
0~127： 0xxxxxxx 表示，首位是 0
128～2047：110xxxxx 10xxxxxx 表示，第一字节首位是 110，第二字节首位是 10
2048～65535：1110xxxx 10xxxxxx 10xxxxxx 表示，第一字节首位是 1110，第二字节首位是 10，第三字节首位是 10
有些不可以用键盘输入的字符，可以用转义序列表示
\uhhhh，其中 h 是16进制数，两个字节的转义
\xhh，表示的是一个字节转义
```
* 字符串与字节slice
```
// 4个标准包对字符串操作特别重要：bytes, strings, strconv, unicode
strings: 提供了函数，用于搜索，替换，比较，修整，切分与连接字符串
bytes: 也有类似函数，用于操作字节slice ([]byte 类型)
strconv: 提供的函数，用于转换布尔值，整数，浮点数为与之对应的字符串形式，或者把字符串转换为布尔值，整数，浮点数，或添加/去除引号
unicode: 具有判别文字符号值等特性的函数，如IsDigit、IsLetter、IsUpper等
// 字符串无法修改单个字节，但 字节slice 可以修改
s := "hello"
s[0] = 'L' // 编译错误
b := []byte(s) // 类型转换为 []byte, 并且会复制一份副本, 填入 s 含有的字节, 并生成一个 slice 引用指向整个数组
b[1] = 'a' // 正确
```
* bytes 包提供的 Buffer 类型可以高效处理 []byte

  


